using System;
using System.Linq;
using System.Threading;
using Microsoft.CodeAnalysis;
using Aspid.Generator.Helpers;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Aspid.MVVM.Generators.Descriptions.Classes;
using static Aspid.MVVM.Generators.Descriptions.Defines;
using static Aspid.MVVM.Generators.Descriptions.General;

namespace Aspid.MVVM.Unity.Generators.ContextMenu;

[Generator(LanguageNames.CSharp)]
public sealed class AddComponentContextMenuGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider.ForAttributeWithMetadataName(AddComponentContextMenuAttribute.FullName, SyntacticPredicate, Find)
            .Where(foundForSourceGenerator => foundForSourceGenerator.IsNeed)
            .Select((foundForSourceGenerator, _) => foundForSourceGenerator.Container);
        
        context.RegisterSourceOutput(
            source: provider,
            action: GenerateCode);
    }
    
    private static bool SyntacticPredicate(SyntaxNode node, CancellationToken cancellationToken) => 
        node is ClassDeclarationSyntax;

    private static FoundForGenerator<ContextMenuData> Find(GeneratorAttributeSyntaxContext context, CancellationToken cancellationToken)
    {
        var declaration = (ClassDeclarationSyntax)context.TargetNode;
        if (context.TargetSymbol is not INamedTypeSymbol symbol) return default;

        if (symbol.HasAnyAttribute(out var attribute, AddComponentContextMenuAttribute))
        {
            if (attribute!.ConstructorArguments[0].Value is not ITypeSymbol type) return default;

            string? path = null;
            
            if (attribute.ConstructorArguments.Length > 1)
                path = attribute.ConstructorArguments[1].Value?.ToString();

            var arguments = attribute.NamedArguments;
            var priority = (int)(arguments.FirstOrDefault(pair => pair.Key == "Priority").Value.Value ?? 100001);

            return new FoundForGenerator<ContextMenuData>(new ContextMenuData(declaration, symbol, symbol.Name, type.Name, path, priority));
        }

        return default;

        string? GetName(string? path) =>
            path?.Substring(path.LastIndexOf("/", StringComparison.Ordinal) + 1);
    }

    private static void GenerateCode(SourceProductionContext context, ContextMenuData data)
    {
        var code = new CodeWriter();
        
        var declaration = data.Declaration;
        var @namespace = declaration.GetNamespaceName();
        var declarationText = declaration.GetDeclarationText();
        var hasNamespace = !string.IsNullOrWhiteSpace(@namespace);

        code.AppendLine($"#if {UNITY_EDITOR}")
            .AppendLine("// <auto-generated>")
            .AppendLine();
        
        if (hasNamespace)
        {
            code.AppendLine($"namespace {@namespace}")
                .BeginBlock();
        }

        var path = data.Path ?? data.Name;
        var editorBrowsable= $"{EditorBrowsableAttribute}({EditorBrowsableState}.Never)";

        code.AppendMultiline(
            $$"""
              [{{editorBrowsable}}]
              {{GeneratedAddComponentContextMenuGeneratorAttribute}}
              internal static class __{{declarationText.Name}}Editor
              {
                  [{{editorBrowsable}}]
                  {{GeneratedAddComponentContextMenuGeneratorAttribute}}
                  [{{MenuItem}}("CONTEXT/{{data.Type}}/{{path}}", priority = {{data.Priority}})]
                  private static void AddContextMenu({{MenuCommand}} command)
                  {
                      var gameObject = (({{Component}})command.context).gameObject;
                      gameObject.AddComponent(typeof({{data.Symbol.ToDisplayStringGlobal()}}));
                  }
              }
              """);
        
        if (hasNamespace)
            code.EndBlock();

        code.AppendLine("#endif");
        context.AddSource("__" + declarationText.GetFileName(@namespace, "Editor"), code.GetSourceText());
    }
}